{"backend_state":"init","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-449dc9db-7c99-42db-9b5c-f26c40f7ef72.json","kernel":"python3","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.10"}},"trust":true,"type":"settings"}
{"cell_type":"code","exec_count":0,"id":"601afe","input":"","pos":19,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"a53d50","input":"","pos":26,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"ab0f50","input":"","pos":24,"type":"cell"}
{"cell_type":"code","exec_count":3,"id":"2d1c46","input":"import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg # import the image module\n\nx = mpimg.imread(\"bw.png\") # read the image into an array x\nx = np.mean(x, axis=2)\n\nprint(np.round(x, 1)) # print x, rounding to 1 d.p.","output":{"0":{"name":"stdout","output_type":"stream","text":"[[0.3 0.4 0.3 0.4 0.3 0.2 0.3 0.3]\n [0.4 0.5 0.5 0.5 0.4 0.3 0.3 0.3]\n [0.4 0.6 0.7 0.8 0.6 0.4 0.3 0.3]\n [0.5 0.8 0.9 0.9 0.8 0.5 0.3 0.3]\n [0.5 0.8 0.9 0.9 0.8 0.5 0.4 0.3]\n [0.4 0.6 0.8 0.8 0.6 0.6 0.6 0.4]\n [0.4 0.5 0.5 0.5 0.4 0.6 1.  0.6]\n [0.3 0.3 0.3 0.3 0.3 0.4 0.5 0.4]]\n"}},"pos":2,"type":"cell"}
{"cell_type":"code","exec_count":37,"id":"eee997","input":"import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ncap = cv2.VideoCapture('atomic.avi')\n\nframeCount = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))\nframeWidth = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))\nframeHeight = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n\nbuf = np.zeros((frameCount, frameHeight, frameWidth, 3), np.dtype('int16'))\n\nfc = 0\nret = True\n\nwhile (fc < frameCount  and ret):\n    ret, buf[fc] = cap.read()\n    fc += 1\n\ncap.release()\n\nprint(\"Number of frames:\", buf.shape[0])\n\ndata = np.mean(buf[:,:,:,:], axis=-1)","output":{"0":{"name":"stdout","output_type":"stream","text":"Number of frames: 200\n"}},"pos":16,"type":"cell"}
{"cell_type":"code","exec_count":38,"id":"680162","input":"x = data[0,:,:] # extract the first frame\n\nplt.imshow(x)","output":{"0":{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x7f80dc4d7370>"},"exec_count":38,"output_type":"execute_result"},"1":{"data":{"image/png":"9fd319c6623cc8b2d4238b705554319c1aa5385a","text/plain":"<Figure size 864x504 with 1 Axes>"},"exec_count":38,"metadata":{"image/png":{"height":414,"width":548},"needs_background":"light"},"output_type":"execute_result"}},"pos":18,"type":"cell"}
{"cell_type":"code","exec_count":39,"id":"1fb4c7","input":"x_min = 400\nx_max = 600\ny_min = 10\ny_max = 150\n\nplt.imshow(x)\nplt.axvline(x_min)\nplt.axvline(x_max)\nplt.axhline(y_min)\nplt.axhline(y_max)\n","output":{"0":{"data":{"text/plain":"<matplotlib.lines.Line2D at 0x7f80dc6fafa0>"},"exec_count":39,"output_type":"execute_result"},"1":{"data":{"image/png":"46b02a8ca248c93ee8da83c8e381e1d33a2dbc08","text/plain":"<Figure size 864x504 with 1 Axes>"},"exec_count":39,"metadata":{"image/png":{"height":414,"width":548},"needs_background":"light"},"output_type":"execute_result"}},"pos":20,"type":"cell"}
{"cell_type":"code","exec_count":4,"id":"b4ce2f","input":"print(\"Min:\", np.min(x))\nprint(\"Max:\", np.max(x))","output":{"0":{"name":"stdout","output_type":"stream","text":"Min: 0.25\nMax: 1.0\n"}},"pos":5,"type":"cell"}
{"cell_type":"code","exec_count":40,"id":"106d85","input":"x = data[0, y_min:y_max, x_min:x_max]\nplt.imshow(x)","output":{"0":{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x7f80dc2f0850>"},"exec_count":40,"output_type":"execute_result"},"1":{"data":{"image/png":"15b4a81c1415e44b2ac6543b8d98e2abb76da38e","text/plain":"<Figure size 864x504 with 1 Axes>"},"exec_count":40,"metadata":{"image/png":{"height":413,"width":584},"needs_background":"light"},"output_type":"execute_result"}},"pos":21,"type":"cell"}
{"cell_type":"code","exec_count":41,"id":"19fb91","input":"x = data[10, y_min:y_max, x_min:x_max]\nplt.figure()\nplt.imshow(x)\n\nx_threshold = (x > 200).astype(int)\nplt.figure()\nplt.imshow(x_threshold)","output":{"0":{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x7f80dc21ba30>"},"exec_count":41,"output_type":"execute_result"},"1":{"data":{"image/png":"5e2d6946d4d23a7d4d344d68cc98d33a029500b0","text/plain":"<Figure size 864x504 with 1 Axes>"},"exec_count":41,"metadata":{"image/png":{"height":413,"width":584},"needs_background":"light"},"output_type":"execute_result"},"2":{"data":{"image/png":"3b040907d4fa324491af27823bb0ce193d4b2373","text/plain":"<Figure size 864x504 with 1 Axes>"},"exec_count":41,"metadata":{"image/png":{"height":413,"width":584},"needs_background":"light"},"output_type":"execute_result"}},"pos":23,"type":"cell"}
{"cell_type":"code","exec_count":5,"id":"f95c1d","input":"x_threshold = (x > 0.5).astype(int)\nprint(x_threshold)","output":{"0":{"name":"stdout","output_type":"stream","text":"[[0 0 0 0 0 0 0 0]\n [0 0 1 1 0 0 0 0]\n [0 1 1 1 1 0 0 0]\n [0 1 1 1 1 0 0 0]\n [1 1 1 1 1 0 0 0]\n [0 1 1 1 1 1 1 0]\n [0 0 0 0 0 1 1 1]\n [0 0 0 0 0 0 0 0]]\n"}},"pos":7,"type":"cell"}
{"cell_type":"code","exec_count":54,"id":"808187","input":"\nnum_frames = 20\nx_pos_array = np.zeros(num_frames)\ny_pos_array = np.zeros(num_frames)\nfor i in range(num_frames):\n    x = data[i, y_min:y_max, x_min:x_max]\n    x_threshold = (x > 200).astype(int)\n    import scipy.ndimage as sn # import the scipy.ndimage package\n    x_labels, n = sn.label(x_threshold) # generate \n    print(\"number of blobs:\", n)\n\n    sizes = sn.sum(x_threshold, x_labels, range(1, n+1))\n    print(\"sizes:\", sizes)\n\n    idx = np.argmax(sizes) # get the index of the largest blob\n    print(\"index:\", idx)\n\n    location = sn.center_of_mass(x_threshold, x_labels, idx + 1) # determine the coordinates of the largest blob\n    y_pos, x_pos = location\n    print(\"co-ordinates:\", x_pos, y_pos)\n    \n    x_pos_array[i] = x_pos\n    y_pos_array[i] = y_pos\n    \n    \nplt.figure(figsize=(5,5))\nplt.plot(x_pos_array, y_pos_array)\nplt.xlim(0, x_max-x_min)\nplt.ylim(0, y_max-y_min)\n","output":{"0":{"name":"stdout","output_type":"stream","text":"number of blobs: 1\nsizes: [29.]\nindex: 0\nco-ordinates: 75.41379310344827 34.724137931034484\nnumber of blobs: 1\nsizes: [32.]\nindex: 0\nco-ordinates: 77.5 39.5\nnumber of blobs: 1\nsizes: [31.]\nindex: 0\nco-ordinates: 80.7741935483871 35.516129032258064\nnumber of blobs: 1\nsizes: [33.]\nindex: 0\nco-ordinates: 74.42424242424242 38.42424242424242\nnumber of blobs: 1\nsizes: [38.]\nindex: 0\nco-ordinates: 74.10526315789474 39.21052631578947\nnumber of blobs: 1\nsizes: [37.]\nindex: 0\nco-ordinates: 74.64864864864865 41.054054054054056\nnumber of blobs: 1\nsizes: [34.]\nindex: 0\nco-ordinates: 77.5 37.705882352941174\nnumber of blobs: 2\nsizes: [36.  2.]\nindex: 0\nco-ordinates: 79.52777777777777 36.138888888888886\nnumber of blobs: 1\nsizes: [35.]\nindex: 0\nco-ordinates: 81.57142857142857 34.77142857142857\nnumber of blobs: 2\nsizes: [39.  1.]\nindex: 0\nco-ordinates: 88.3076923076923 32.82051282051282\nnumber of blobs: 1\nsizes: [29.]\nindex: 0\nco-ordinates: 90.44827586206897 34.310344827586206\nnumber of blobs: 2\nsizes: [32.  6.]\nindex: 0\nco-ordinates: 92.84375 34.625\nnumber of blobs: 2\nsizes: [30. 12.]\nindex: 0\nco-ordinates: 88.5 36.666666666666664\nnumber of blobs: 2\nsizes: [33. 17.]\nindex: 0\nco-ordinates: 84.87878787878788 44.06060606060606\nnumber of blobs: 2\nsizes: [31. 27.]\nindex: 0\nco-ordinates: 80.19354838709677 46.774193548387096\nnumber of blobs: 1\nsizes: [30.]\nindex: 0\nco-ordinates: 78.2 49.333333333333336\nnumber of blobs: 2\nsizes: [16.  3.]\nindex: 0\nco-ordinates: 80.5625 44.25\nnumber of blobs: 1\nsizes: [17.]\nindex: 0\nco-ordinates: 81.52941176470588 43.0\nnumber of blobs: 1\nsizes: [32.]\nindex: 0\nco-ordinates: 82.28125 49.8125\nnumber of blobs: 1\nsizes: [33.]\nindex: 0\nco-ordinates: 84.0 46.0\n"},"1":{"data":{"text/plain":"(0.0, 140.0)"},"exec_count":54,"output_type":"execute_result"},"2":{"data":{"image/png":"9a253c68e4518757a0b397b37cdb2c843d7f66e2","text/plain":"<Figure size 360x360 with 1 Axes>"},"exec_count":54,"metadata":{"image/png":{"height":306,"width":329},"needs_background":"light"},"output_type":"execute_result"}},"pos":25,"type":"cell"}
{"cell_type":"code","exec_count":6,"id":"972b64","input":"x_threshold = (x > 0.7).astype(int)\nprint(x_threshold)\nplt.imshow(x_threshold)","output":{"0":{"name":"stdout","output_type":"stream","text":"[[0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0]\n [0 0 1 1 0 0 0 0]\n [0 1 1 1 1 0 0 0]\n [0 1 1 1 1 0 0 0]\n [0 0 1 1 0 0 0 0]\n [0 0 0 0 0 0 1 0]\n [0 0 0 0 0 0 0 0]]\n"},"1":{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x7fb4f110d8e0>"},"exec_count":6,"output_type":"execute_result"},"2":{"data":{"image/png":"69c37bed46d7697e172fc244c07e5b7154209e25","text/plain":"<Figure size 864x504 with 1 Axes>"},"exec_count":6,"metadata":{"image/png":{"height":411,"width":408},"needs_background":"light"},"output_type":"execute_result"}},"pos":9,"type":"cell"}
{"cell_type":"code","exec_count":7,"id":"9d7e35","input":"import scipy.ndimage as sn # import the scipy.ndimage package\nx_labels, n = sn.label(x_threshold) # generate \nprint(\"number of blobs:\", n)\n\nsizes = sn.sum(x_threshold, x_labels, range(1, n+1))\nprint(\"sizes:\", sizes)\n\nidx = np.argmax(sizes) # get the index of the largest blob\nprint(\"index:\", idx)\n\nlocation = sn.center_of_mass(x_threshold, x_labels, idx + 1) # determine the coordinates of the largest blob\ny_pos, x_pos = location\nprint(\"co-ordinates:\", x_pos, y_pos)","output":{"0":{"name":"stdout","output_type":"stream","text":"number of blobs: 2\nsizes: [12.  1.]\nindex: 0\nco-ordinates: 2.5 3.5\n"}},"pos":11,"type":"cell"}
{"cell_type":"code","exec_count":8,"id":"62b288","input":"plt.imshow(x) # swho the original image\nplt.scatter(x_pos, y_pos, color=\"black\", marker=\"x\", s=200)","output":{"0":{"data":{"text/plain":"<matplotlib.collections.PathCollection at 0x7fb4e8f2fac0>"},"exec_count":8,"output_type":"execute_result"},"1":{"data":{"image/png":"007429252992d6f36651dfe78e5a4c4d6a13e3f7","text/plain":"<Figure size 864x504 with 1 Axes>"},"exec_count":8,"metadata":{"image/png":{"height":411,"width":408},"needs_background":"light"},"output_type":"execute_result"}},"pos":13,"type":"cell"}
{"cell_type":"markdown","id":"057620","input":"The image `frame0.png` is part of one frame of the Brownian motion video.\n\n> Determine the x- and y-coordinates of the particle in the image `frame0.png`.\n> 1. Read the image into an array\n> 1. Threshold the image using a suitable threshold value\n> 1. Segment the image and determine the location of the largest blob\n> 1. Mark the location of the particle on the image","pos":14,"type":"cell"}
{"cell_type":"markdown","id":"1541d7","input":"> Use segmentation to determine the x,y-co-ordinates of the particle in the cropped frame. Repeat for a few other frames in the range 0...10. Can you find a threshold value that works across all frames in this range?","pos":22,"type":"cell"}
{"cell_type":"markdown","id":"29afe9","input":"## Segmentation\n\nThe next step is to identify the blobs and determine their size and locations. There is a package called `scipy.ndimage` which contains functions to do exactly this. The following code identifies and prints the number of blobs, their sizes and the co-ordinates of the largest one: ","pos":10,"type":"cell"}
{"cell_type":"markdown","id":"448e85","input":"## Videos\n\nOur goal is to track the location of a moving particle across a sequence of frames of a video. A video is essentially a sequence of frame-by-frame still images, so we can reuse the techniques above.\n\nThe following code loads a video file into an array called `data` and prints out the number of frames:","pos":15,"type":"cell"}
{"cell_type":"markdown","id":"8e3a0f","input":"An image is essentially a 2-dimensional array where each element represents the colour intensity of each pixel.\n\nFirst we import the module `matplotlib.image` and use the `imread` function to convert it to an array.","pos":1,"type":"cell"}
{"cell_type":"markdown","id":"9ca7d4","input":"We can then extract the first frame (frame number 0) into an array `x`:","pos":17,"type":"cell"}
{"cell_type":"markdown","id":"b45caf","input":"> Experiment with different threshold values. Is it possible to isolate just the large (top) blob?\n\nYou should have found that you can isolate the smaller (bottom) blob, or two distinct blobs, but it's not possible to find a value which isolates just the larger (top) blob.\n\nLet's use the value 0.7 which results in two disconnected blobs. We'll also display the array `x_threshold` as an image using the function `plt.imshow`:","pos":8,"type":"cell"}
{"cell_type":"markdown","id":"b45d3f","input":"We have identified that the largest blob as co-ordinates (2.5, 3.5). Using `plt.scatter` we can mark this location on the image:","pos":12,"type":"cell"}
{"cell_type":"markdown","id":"d5cbd3","input":"## Thresholding\nThe next step is to threshold the image, generating an array whose values are 1 for pixels above the threshold, and 0 for pixels below the threshold. The threshold value should of course be between the minimum and maximum values in this array:","pos":4,"type":"cell"}
{"cell_type":"markdown","id":"d9869a","input":"> Upload the file `bw.png` and use the above code to read it into an array.","pos":3,"type":"cell"}
{"cell_type":"markdown","id":"e5ffbb","input":"Let's choose a threshold value of 0.5. The following code creates an array `x_threshold` whose values are 1 only for pixels above 0.5:","pos":6,"type":"cell"}
{"cell_type":"markdown","id":"fd3e2e","input":"# Workshop 4: Image Segmentation\n\nImage segmentation is the process of partitioning a image or video into regions, typically for the purpose of identifying specific objects or features. For example, identifying different tissue types in medical images, or distinguishing objects in astronomical images.\n<img src=\"https://d3i71xaburhd42.cloudfront.net/1b699b098ec7a5e539afd8370d71a82d41e3370d/3-Figure1-1.png\" width=\"400px\" />\n\nIn this workshop, you will use image segmentation techniques to reproduce part of a famous experiment - Jean Perrin’s confirmation of Einstein’s Brownian motion equation.\n\nIn this experiment, tiny particles suspended in water are observed through a microscope. Due to collisions with water molecules, the particles appear to move in a random and erratic fashion known as [Brownian motion](https://en.wikipedia.org/wiki/Brownian_motion). In 1908 Jean Baptiste Perrin experimentally validate Einstein's kinetic theory of Brownian motion, providing the first direct evidence of the atomic nature of matter and enabling the calculation of an estimate of Avogadro's number.\n\nOur goal is to use image segmentation to track the x- and y- coordinates of one of the particles in the video below.\n\n<iframe width=\"650\" height=\"395\" src=\"https://mediacentral.ucl.ac.uk/player?autostart=n&videoId=f63a5H5i&captions=y&chapterId=0\" frameborder=\"0\" scrolling=\"no\"  allowfullscreen></iframe>\n\nWe will perform the following steps to each frame of the video:\n\n1. Read the image data into a numpy array\n1. Crop the image so that only one particle is in view\n1. Threshold the image to distinguish particle from background\n1. Identify the particle x- and y-coordinates using segmentation techniques\n1. Store the co-ordinates in an array\n\nThe guts of this process is step 3, so we will study this first using a small sample image.\n\n## Images\n`bw.png` is an 8x8 pixel image:\n\n![](bw_big.png)\n\nThe image contains two particles, and our goal is to identify the larger one and determine its co-ordinates.\n","pos":0,"type":"cell"}
{"id":0,"time":1630791529791,"type":"user"}
{"last_load":1630791530042,"type":"file"}