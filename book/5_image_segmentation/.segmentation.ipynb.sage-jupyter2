{"backend_state":"init","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-724122d3-5f61-48a4-87ee-19c3c7d02a7d.json","kernel":"python3","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.10"}},"trust":true,"type":"settings"}
{"cell_type":"code","exec_count":0,"id":"bd1d50","input":"","pos":41,"type":"cell"}
{"cell_type":"code","exec_count":11,"id":"1541d7","input":"A_threshold = (A > 0.7).astype(int)\nprint(A_threshold)\nplt.imshow(A_threshold)","output":{"0":{"name":"stdout","output_type":"stream","text":"[[0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0]\n [0 0 1 1 0 0 0 0]\n [0 1 1 1 1 0 0 0]\n [0 1 1 1 1 0 0 0]\n [0 0 1 1 0 0 0 0]\n [0 0 0 0 0 0 1 0]\n [0 0 0 0 0 0 0 0]]\n"},"1":{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x7fdb849938b0>"},"exec_count":11,"output_type":"execute_result"},"2":{"data":{"image/png":"69c37bed46d7697e172fc244c07e5b7154209e25","text/plain":"<Figure size 864x504 with 1 Axes>"},"exec_count":11,"metadata":{"image/png":{"height":411,"width":408},"needs_background":"light"},"output_type":"execute_result"}},"pos":22,"type":"cell"}
{"cell_type":"code","exec_count":12,"id":"ab0f50","input":"import scipy.ndimage as sn # import the scipy.ndimage package\n\n# Label the connected components (blobs) of binary image A_threshold\nA_labels, n = sn.label(A_threshold) \nprint(\"number of blobs:\", n)\n\n# Count the number of pixels in each blob and return as array \"sizes\"\nsizes = sn.sum(A_threshold, A_labels, range(1, n+1))\nprint(\"sizes:\", sizes)\n\n# Get the index of the largest value in sizes (corresponding to the largest blob)\nidx = np.argmax(sizes) \nprint(\"index:\", idx)\n\n# Determine the co-ordinates of the largest blob (returned as row, column indices)\ny_pos, x_pos = sn.center_of_mass(A_threshold, A_labels, idx + 1) \nprint(\"co-ordinates of largest blob:\", x_pos, y_pos)","output":{"0":{"name":"stdout","output_type":"stream","text":"number of blobs: 2\nsizes: [12.  1.]\nindex: 0\nco-ordinates of largest blob: 2.5 3.5\n"}},"pos":24,"type":"cell"}
{"cell_type":"code","exec_count":13,"id":"a53d50","input":"plt.imshow(A) # show the original image\nplt.scatter(x_pos, y_pos, color=\"black\", marker=\"x\", s=200)","output":{"0":{"data":{"text/plain":"<matplotlib.collections.PathCollection at 0x7fdb9a49b640>"},"exec_count":13,"output_type":"execute_result"},"1":{"data":{"image/png":"007429252992d6f36651dfe78e5a4c4d6a13e3f7","text/plain":"<Figure size 864x504 with 1 Axes>"},"exec_count":13,"metadata":{"image/png":{"height":411,"width":408},"needs_background":"light"},"output_type":"execute_result"}},"pos":26,"type":"cell"}
{"cell_type":"code","exec_count":15,"id":"94fc46","input":"f = data[0,:,:] # extract the first frame\n\nplt.imshow(f)","output":{"0":{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x1227ebbb0>"},"exec_count":15,"output_type":"execute_result"},"1":{"data":{"image/png":"ab27513ca5e2d1c25287e56a5f0e80d1cb6ba55c","text/plain":"<Figure size 432x288 with 1 Axes>"},"exec_count":15,"metadata":{"needs_background":"light"},"output_type":"execute_result"}},"pos":31,"type":"cell"}
{"cell_type":"code","exec_count":16,"id":"b0f2cb","input":"import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ncap = cv2.VideoCapture('atomic.avi')\n\nframeCount = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))\nframeWidth = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))\nframeHeight = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n\nbuf = np.zeros((frameCount, frameHeight, frameWidth, 3), np.dtype('int16'))\n\nfc = 0\nret = True\n\nwhile (fc < frameCount  and ret):\n    ret, buf[fc] = cap.read()\n    fc += 1\n\ncap.release()\n\ndata = np.mean(buf[:,:,:,:], axis=-1)\n\nprint(\"Data array dimensions:\", data.shape)\nprint(\"Number of frames:\", data.shape[0])","output":{"0":{"name":"stdout","output_type":"stream","text":"Data array dimensions: (200, 480, 640)\nNumber of frames: 200\n"}},"pos":29,"type":"cell"}
{"cell_type":"code","exec_count":16,"id":"e86463","input":"x_min = 400\nx_max = 600\ny_min = 10\ny_max = 150\n\n# Indicate cropping boundaries\nplt.figure(figsize=(7,7))\nplt.imshow(f)\nplt.axvline(x_min)\nplt.axvline(x_max)\nplt.axhline(y_min)\nplt.axhline(y_max)\n\nf_cropped = data[0, y_min:y_max, x_min:x_max]\n\n# Cropped figure\nplt.figure(figsize=(7,7))\nplt.imshow(f_cropped)","output":{"0":{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x1418a68e0>"},"exec_count":16,"output_type":"execute_result"},"1":{"data":{"image/png":"af2cc2e94f585236cd54b0bf3e92188e08194a05","text/plain":"<Figure size 504x504 with 1 Axes>"},"exec_count":16,"metadata":{"needs_background":"light"},"output_type":"execute_result"},"2":{"data":{"image/png":"5edf7807d565cf380fdba8eb5712a626e783ee45","text/plain":"<Figure size 504x504 with 1 Axes>"},"exec_count":16,"metadata":{"needs_background":"light"},"output_type":"execute_result"}},"pos":33,"scrolled":true,"type":"cell"}
{"cell_type":"code","exec_count":17,"id":"2d1c46","input":"import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg # import the image module\n\nA = mpimg.imread(\"bw.png\") # read the image into an array A\nA = np.mean(A, axis=2)\n\nprint(np.round(A, 2)) # print x, rounding to 2 d.p.","output":{"0":{"name":"stdout","output_type":"stream","text":"[[0.27 0.35 0.27 0.37 0.31 0.25 0.29 0.29]\n [0.37 0.46 0.51 0.53 0.45 0.31 0.3  0.28]\n [0.45 0.6  0.75 0.8  0.57 0.43 0.34 0.31]\n [0.46 0.76 0.9  0.89 0.82 0.45 0.32 0.34]\n [0.51 0.79 0.9  0.92 0.75 0.49 0.43 0.29]\n [0.44 0.56 0.75 0.76 0.59 0.56 0.62 0.42]\n [0.36 0.48 0.49 0.47 0.45 0.61 1.   0.56]\n [0.28 0.34 0.31 0.26 0.31 0.4  0.49 0.37]]\n"}},"pos":2,"type":"cell"}
{"cell_type":"code","exec_count":18,"id":"d5cbd3","input":"print(A.shape)","output":{"0":{"name":"stdout","output_type":"stream","text":"(8, 8)\n"}},"pos":4,"type":"cell"}
{"cell_type":"code","exec_count":19,"id":"e5ffbb","input":"print(A[0, 0])","output":{"0":{"name":"stdout","output_type":"stream","text":"0.26764706\n"}},"pos":6,"type":"cell"}
{"cell_type":"code","exec_count":20,"id":"b45caf","input":"print(A[0, 8])","output":{"0":{"ename":"IndexError","evalue":"index 8 is out of bounds for axis 1 with size 8","output_type":"error","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mIndexError\u001b[0m                                Traceback (most recent call last)","\u001b[0;32m/tmp/ipykernel_2397/161630308.py\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mA\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m8\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m","\u001b[0;31mIndexError\u001b[0m: index 8 is out of bounds for axis 1 with size 8"]}},"pos":8,"type":"cell"}
{"cell_type":"code","exec_count":21,"id":"29afe9","input":"print(A[:, 2])","output":{"0":{"name":"stdout","output_type":"stream","text":"[0.2735294  0.5088235  0.74705887 0.89705884 0.89705884 0.75\n 0.49411765 0.30588236]\n"}},"pos":10,"type":"cell"}
{"cell_type":"code","exec_count":22,"id":"b45d3f","input":"print(A[1, 3:7])","output":{"0":{"name":"stdout","output_type":"stream","text":"[0.5323529  0.44705883 0.30882353 0.30294117]\n"}},"pos":12,"type":"cell"}
{"cell_type":"code","exec_count":23,"id":"057620","input":"# Adjust these index values to isolate the red box\n\nA_cropped = A[0:8, 0:8]\n\nplt.imshow(A_cropped, \n            cmap=plt.get_cmap('Greys_r') )\n\n# NB This line ensures that the colour scaling remains consistent regardless of cropping\nplt.clim(np.amin(A), np.amax(A))","output":{"0":{"data":{"image/png":"7cf3dae75d41a6d8da382c171fb7f61ef5d8adc3","text/plain":"<Figure size 864x504 with 1 Axes>"},"exec_count":23,"metadata":{"image/png":{"height":411,"width":408},"needs_background":"light"},"output_type":"execute_result"}},"pos":14,"tags":{"remove-output":true},"type":"cell"}
{"cell_type":"code","exec_count":24,"id":"bf0084","input":"num_frames = 20\n\n# Create arrays for storing blob coordinates\nx_pos_array = np.zeros(num_frames)\ny_pos_array = np.zeros(num_frames)\n\nfor i in range(num_frames):\n    \n    f = data[i, y_min:y_max, x_min:x_max]\n    \n    # Add code to obtain the x and y coordinates of the largest particle in the current frame here\n    # ...\n    \n    # Store the current coordinates in the corresponding position \n    x_pos_array[i] = x_pos\n    y_pos_array[i] = y_pos\n","output":{"0":{"ename":"NameError","evalue":"name 'y_min' is not defined","output_type":"error","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)","\u001b[0;32m/tmp/ipykernel_2397/2136523447.py\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m      7\u001b[0m \u001b[0;32mfor\u001b[0m \u001b[0mi\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mrange\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mnum_frames\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      8\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 9\u001b[0;31m     \u001b[0mf\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mdata\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mi\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my_min\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0my_max\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mx_min\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0mx_max\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     10\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     11\u001b[0m     \u001b[0;31m# Add code to obtain the x and y coordinates of the largest particle in the current frame here\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;31mNameError\u001b[0m: name 'y_min' is not defined"]}},"pos":37,"tags":{"remove-output":true},"type":"cell"}
{"cell_type":"code","exec_count":25,"id":"01e59b","input":"# Threshold value\nt = 70\n\nf = data[0, y_min:y_max, x_min:x_max]\nplt.figure()\nplt.imshow(f)\n\nf_threshold = (f > t).astype(int)\nplt.figure()\nplt.imshow(f_threshold)\n\n# Add code to determine blob coordinates\n# x, y =  ...","output":{"0":{"ename":"NameError","evalue":"name 'y_min' is not defined","output_type":"error","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)","\u001b[0;32m/tmp/ipykernel_2397/1895023898.py\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m      2\u001b[0m \u001b[0mt\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;36m70\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      3\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 4\u001b[0;31m \u001b[0mf\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mdata\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my_min\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0my_max\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mx_min\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0mx_max\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      5\u001b[0m \u001b[0mplt\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfigure\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      6\u001b[0m \u001b[0mplt\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mimshow\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mf\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;31mNameError\u001b[0m: name 'y_min' is not defined"]}},"pos":35,"tags":{"remove-output":true},"type":"cell"}
{"cell_type":"code","exec_count":8,"id":"9ca7d4","input":"print(\"Min:\", np.min(A))\nprint(\"Max:\", np.max(A))","output":{"0":{"name":"stdout","output_type":"stream","text":"Min: 0.25\nMax: 1.0\n"}},"pos":17,"type":"cell"}
{"cell_type":"code","exec_count":9,"id":"601afe","input":"A_threshold = (A > 0.5).astype(int)\nprint(A_threshold)","output":{"0":{"name":"stdout","output_type":"stream","text":"[[0 0 0 0 0 0 0 0]\n [0 0 1 1 0 0 0 0]\n [0 1 1 1 1 0 0 0]\n [0 1 1 1 1 0 0 0]\n [1 1 1 1 1 0 0 0]\n [0 1 1 1 1 1 1 0]\n [0 0 0 0 0 1 1 1]\n [0 0 0 0 0 0 0 0]]\n"}},"pos":19,"type":"cell"}
{"cell_type":"markdown","id":"106d85","input":"> Experiment with different threshold values. Is it possible to isolate just the large (top) blob?\n\nYou should have found that you can isolate the smaller (bottom) blob, or two distinct blobs, but it's not possible to find a value which isolates just the larger (top) blob.\n\nLet's use the value 0.7 which results in two disconnected blobs. We'll also display the array `A_threshold` as an image using the function `plt.imshow`:","pos":21,"type":"cell"}
{"cell_type":"markdown","id":"19fb91","input":"## Segmentation\n\nThe next step is to identify the blobs and determine their size and locations. There is a package called `scipy.ndimage` which contains functions to do exactly this. The following code uses [connected component labelling](https://en.wikipedia.org/wiki/Connected-component_labeling) to identify and print the number of blobs, their sizes and the co-ordinates of the largest one: ","pos":23,"type":"cell"}
{"cell_type":"markdown","id":"1fb4c7","input":"Here we used the logical operator `>` \"greater than\". The expression `A > 0.5` is a logical comparison between the array `A` and the value `0.5`, and returns a new array that is `True` (= 1) where the comparison succeeds and `False` (= 0) where it fails.","pos":20,"type":"cell"}
{"cell_type":"markdown","id":"2165db","input":"> Repeat for a few other frames in the range 0...10. Can you find a threshold value that works across all frames in this range?\n\nOur final task is to track the random movement of a single particle over time. We already have the tools to isolate a particle and determine its coordinates. All that's left is to store those coordinates for a series of points in time.\n\nTo do this, we'll first create arrays to store the coordinates. Then we'll repeat our segmentation process for a sequence of frames, storing the coordinates as we go. \n\n> Edit the code below to complete the task","pos":36,"type":"cell"}
{"cell_type":"markdown","id":"448e85","input":"You can learn more about indexing and slicing, including more advanced syntax [here](https://numpy.org/doc/stable/user/basics.indexing.html)","pos":15,"type":"cell"}
{"cell_type":"markdown","id":"6133af","input":"> You can recreate the figure above using the following code:\n\n```\nplt.figure(figsize=(5,5))\nax = plt.gca()\n \nplt.plot(x_pos_array, y_pos_array)\nplt.xlim(0, x_max-x_min)\nplt.ylim(0, y_max-y_min)\n\nax.invert_yaxis()\nax.set_aspect('equal')\n``` ","pos":39,"type":"cell"}
{"cell_type":"markdown","id":"62b288","input":"> Use slice indexing to access the following cropped area of the image stored in `A`:\n\n```{image} slice_exercise.png\n:width: 200px\n```","pos":13,"type":"cell"}
{"cell_type":"markdown","id":"680162","input":"Let's choose a threshold value of 0.5. The following code creates an array `A_threshold` whose values are 1 only for pixels above 0.5 and zero everywhere else:","pos":18,"type":"cell"}
{"cell_type":"markdown","id":"6f1b8f","input":"### Exercise\n\nChoose another particle in the video and repeat the steps above to track its movement.\n","pos":40,"type":"cell"}
{"cell_type":"markdown","id":"769e78","input":"> Use segmentation to determine the x,y-co-ordinates of the particle in the cropped frame. This is a good opportunity to use the function `largest_blob_coords` that you defined previously.","pos":34,"type":"cell"}
{"cell_type":"markdown","id":"808187","input":"We have identified that the largest blob as co-ordinates (2.5, 3.5). Using `plt.scatter` we can mark this location on the image:","pos":25,"type":"cell"}
{"cell_type":"markdown","id":"8a3998","input":"If all goes well, you should have two arrays containing the x and y (or column and row) coordinates as the particle as it moves through time. We can plot those coordinates as a single trajectory:\n![](output.png)","pos":38,"type":"cell"}
{"cell_type":"markdown","id":"8c4f0e","input":"### Crop the Image\n\nNext we will crop the image to only focus on a single bright particle. We will draw some lines on the image to indicate the cropping boundaries, then use slicing to create an array `f_cropped` containing the cropped image. \n","pos":32,"type":"cell"}
{"cell_type":"markdown","id":"8e3a0f","input":"An image is essentially a 2-dimensional array where each element represents the colour intensity of each pixel.\n\nFirst we import the module `matplotlib.image` and use the `imread` function to convert it to an array.","pos":1,"type":"cell"}
{"cell_type":"markdown","id":"972b64","input":"We can also access more than one element at a time! To do that we need the colon `:` syntax. On its own, `:` is used to access every element for a given row or column. So the following will give us every element in the 3rd column: `A[:, 2]`","pos":9,"type":"cell"}
{"cell_type":"markdown","id":"9d7e35","input":"Finally, we can use the `:` syntax to access a *range* of values like so: `start_idx:stop_idx`. This is known as slicing. The value at `start_idx` is included but the value at `stop_idx` is excluded. The following will give us the 4th to 7th values of the 2nd row: `A[1, 3:7]`","pos":11,"type":"cell"}
{"cell_type":"markdown","id":"a547a6","input":"The image `frame0.png` is part of one frame of the Brownian motion video.\n\n<a href=\"../workshop_5/frame0.png\" download>frame0.png (download link)</a>\n\n> Determine the x- and y-coordinates of the particle in the image `frame0.png`.\n> 1. Read the image into an array\n> 1. Threshold the image using a suitable threshold value\n> 1. Segment the image and determine the location of the largest blob\n> 1. Mark the location of the particle on the image\n\nYou will need to repeat this sequence of steps during the next section of the workshop. To avoid needless repetition and, maybe more importantly,  typos and errors, we should encapsulate this process in a function. \n\n> Write a function that takes two inputs: a grayscale image, and a threshold value. Your function should then return the x and y co-ordinates of the largest blob in that image.\n> You may use the following template as a starting point:\n\n```\ndef largest_blob_coords(image, thresh):\n    # Threshold the image\n    bw = (image > thresh).astype(int)\n    # Label the blobs\n    labels, n = sn.label(bw)\n    \n    # Remaining code ...\n    \n    return x_pos, y_pos\n ```  \n\n> Test your function using the 8x8 image `A` from earlier:\n\n```\nA = mpimg.imread(\"bw.png\")\nA = np.mean(A, axis=2)\n\nx, y = largest_blob_coords(A, 0.7)\nprint(x,y)\n\n# should print 2.5 3.5\n```","pos":27,"type":"cell"}
{"cell_type":"markdown","id":"a974b1","input":"### Extract First Frame\n\nOur video is stored as a 200x480x640 array, where the first dimension is the time axis and the second two dimensions are the spatial axes. In other words, the video consists of 200 individual 480x640 pixel frames. We can extract the first frame (frame number 0) into an array `f`, using the indexing concepts introduced earlier.","pos":30,"type":"cell"}
{"cell_type":"markdown","id":"b4ce2f","input":"This outputs the size of each dimension of the array, in this case 8 rows and 8 columns. \n\nIn order to access specific elements of the array, we can use *indexing* and bracket (`[...]`) syntax. For example, the following expression gives the first element of the first row of our array: `A[0, 0]`.","pos":5,"type":"cell"}
{"cell_type":"markdown","id":"d5a602","input":"## Videos\n\nOur goal is to track the location of a moving particle across a sequence of frames of a video. A video is essentially a sequence of frame-by-frame still images, so we can reuse the techniques above. The essential steps are as below:\n\n1. Load the video data into an array\n1. Use array slicing to extract a single frame from the array\n1. Use slicing to crop the frame so that only one particle is visible\n1. Re-use the previous code to identify the particle position\n\n### Load Video Data\n\nThe following code loads a video file into an array called `data` and prints out the dimensions of each frame and the number of frames. You don't need to understand how it works.\n\n<a href=\"../workshop_5/atomic.avi\" download>atomic.avi (download link)</a>","pos":28,"type":"cell"}
{"cell_type":"markdown","id":"d9869a","input":"> Upload the file `bw.png` and use the above code to read it into an array. (First click the link above to download it to your computer).\n\nThe variable `A` stores a numpy array containing the image's pixel data. Lets first investigate a basic property of this array: its shape. Since `shape` is a *property* of a numpy array object, we can access it using dot notation: `A.shape`:","pos":3,"type":"cell"}
{"cell_type":"markdown","id":"eee997","input":"## Thresholding\nThe next step is to threshold the image, generating an array whose values are 1 for pixels above the threshold, and 0 for pixels below the threshold. The threshold value should of course be between the minimum and maximum values in this array:","pos":16,"type":"cell"}
{"cell_type":"markdown","id":"f95c1d","input":"Remember that python starts counting from 0! This means that the first element is at index 0, the second is at index 1 and so on. For a dimension of size 8, the maximum index value is 7. Try using an index value of 8 and see what happens:","pos":7,"type":"cell"}
{"cell_type":"markdown","id":"fd3e2e","input":"\n:::{admonition} Project groups\n:class: warning\n\nFrom next week you will be working on a project in groups of 3-4 students.\n\nIt is up to YOU to choose your team members and if possible you should do this during today's workshop.\n\nSubmit the names of your team members via the link on Moodle.\n:::\n\n# Workshop 5: Image Segmentation\n\nImage segmentation is the process of partitioning a image or video into regions, typically for the purpose of identifying specific objects or features. For example, identifying different tissue types in medical images, or distinguishing objects in astronomical images.\n<img src=\"https://d3i71xaburhd42.cloudfront.net/1b699b098ec7a5e539afd8370d71a82d41e3370d/3-Figure1-1.png\" width=\"400px\" />\n\nIn this workshop, you will use image segmentation techniques to reproduce part of a famous experiment - Jean Perrin’s confirmation of Einstein’s Brownian motion equation.\n\nIn this experiment, tiny particles suspended in water are observed through a microscope. Due to collisions with water molecules, the particles appear to move in a random and erratic fashion known as [Brownian motion](https://en.wikipedia.org/wiki/Brownian_motion). In 1908 Jean Baptiste Perrin experimentally validated Einstein's kinetic theory of Brownian motion, providing the first direct evidence of the atomic nature of matter and enabling the calculation of an estimate of Avogadro's number.\n\nOur goal is to use image segmentation to track the x- and y- coordinates of one of the particles in the video below.\n\n<iframe width=\"650\" height=\"395\" src=\"https://mediacentral.ucl.ac.uk/player?autostart=n&videoId=f63a5H5i&captions=y&chapterId=0\" frameborder=\"0\" scrolling=\"no\"  allowfullscreen></iframe>\n\nWe will perform the following steps to each frame of the video:\n\n1. Read the image data into a numpy array\n1. Crop the image so that only one particle is in view\n1. Threshold the image to distinguish particle from background\n1. Identify the particle x- and y-coordinates using segmentation techniques\n1. Store the co-ordinates in an array\n\nThe key component of this process is step 3, so we will study this first using a small sample image.\n\n:::{admonition} What you'll learn\n:class: hint\n1. How to represent image data an array\n1. How to extract data from the array using slicing\n1. How to use Python libraries to perform image segmentation\n:::\n\n## Images: loading and indexing\n`bw.png` is an 8x8 pixel image.\n\n<a href=\"../workshop_5/bw.png\" download>bw.png (download link)</a>\n\n![](bw_big.png)\n\nThe image contains two particles, and our goal is to identify the larger one and determine its co-ordinates.\n","pos":0,"type":"cell"}
{"id":0,"time":1637669004259,"type":"user"}
{"last_load":1637669003786,"type":"file"}